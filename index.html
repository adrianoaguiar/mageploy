<!DOCTYPE html>
<html>
    <head>
        <meta charset='utf-8'>
        <meta http-equiv="X-UA-Compatible" content="chrome=1">
        <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
        <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
        <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
        <!--[if lt IE 9]>
        <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
        <title>Mageploy - synchronize changes between different Magento environments</title>
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-7971748-33', 'mageploy.com');
            ga('send', 'pageview');
        </script>
    </head>

    <body>
        <div id="container">
            <div class="inner">

                <header>
                    <h1 style="height:210px;text-indent:-9000px;background:transparent url(images/mageploy_256_noborder.png) no-repeat top left;">Mageploy</h1>
                    <h2>Easily keep track of changes and deploy synchronization between different Magento environments.</h2>
                </header>

                <section id="downloads" class="clearfix">
                    <a href="https://github.com/pug-more/mageploy/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
                    <a href="https://github.com/pug-more/mageploy/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
                    <a href="https://github.com/pug-more/mageploy" id="view-on-github" class="button"><span>View on GitHub</span></a>
                </section>

                <hr>

                <section id="main_content">
                    <!--<p><img src="https://raw.github.com/wiki/pug-more/mageploy/mageploy_256_noborder.png" alt="Logo of Mageploy"></p>-->

                    <h1>1. Introduction</h1>

                    <p>If you are reading this documentation you are likely a developer who had the chance to work with Magento. There are several tools that were born with the intent of leveraging the development experience on Magento. Some favourite tools are N98magerun, Modman and Magentleman. Mageploy aims at becoming one of them. It's intended to facilitate the deployment process, keeping different environments synchronized; that's something new to any other tool, as far as we know.</p>

                    <p>What do we intend with the word "deployment"? If you have developed a complete web store with Magento you know that it's not all about code. It's also a matter of doing some activity (sometimes a lot of that) in the Admin Control Panel. Things like creating Attributes, associating them to brand new Attribute Sets, structuring Category trees, changing System Configuration and so on (and on). Once you have done all this kind of work in your development environment you have to be sure that it will be done exactly the same way on each other environment involved in the process: other developers' environments, staging environments and finally the production environment. So, with the word "deploy" we not only mean mantaining code consistency among different environments but also mantaining entities and configuration consistency.</p>

                    <p>Given that you already know how to mantain code consistency (you are on GitHub after all), Mageploy aims at automating the process of mantaining entities and configuration consistency without obliging you to bypass the usage of the Admin Control Panel. Infact, the only other way of mantaining such consistency (the so called "best practice") is that of writing install/upgrade scripts which create entities and change System Configuration programmatically. That's definitively boring and error prone.</p>

                    <h2>1.1 About Mageploy</h2>

                    <p>Mageploy has been developed on <strong>Magento CE v 1.7.0.2</strong> and hasn't been tested with different CE or EE versions yet.</p>

                    <p>The idea of Mageploy was born within a discussion on Magento Stack Exchange named "What is the best deploy strategy?" that you can read at the following URL: <a href="http://magento.stackexchange.com/questions/252/what-is-the-best-deploy-strategy">http://magento.stackexchange.com/questions/252/what-is-the-best-deploy-strategy</a>. In that discussion I asked to Magento developers what was their preferred deploy strategy and answers given to me made me understand that there wasn't any commonly adopted strategy, except for the "definitively boring and error prone" practice of doing a lot of code to mantain consistency among different environments.</p>

                    <p>So the idea of developing Mageploy took place and here we are.</p>

                    <p>The basic idea under Mageploy is that every action you perform in the Magento Admin Control Panel translates into an invocation of a method of a controller. These "action methods" take their parameters from the HTTP request object. So it's all about tracking and serializing these method calls and request parameters into a file and centralizing it under a version control system. Each action you perform on your environment not only is stored into a "global actions" file but also in a "local actions" file which is not versioned. 
                        Are you getting it? Actions performed in other enviroments result from the difference between global actions and your local actions, once you have checked out the global file.</p>

                    <p>Replicating these actions having stored method names and parameters should be a joke, isn't it? Obviously it's not so simple. There is a problem concerning the fact that every environment has its own IDs which you can't count on when they are part of a method's parameters. So we have to focus on finding a way to convert specific IDs into universally unique identifiers (UUIDs) so that we could do our data marshalling and demarshalling without worrying about specific IDs.</p>

                    <p>That's the complex part of Mageploy but that's also its strength and once we are able to perform a conversion from IDs to UUIDs and back we are able to replicate changes between different environments automatically and consistently. Converting IDs into UUIDs can sometimes force some limitations and there is also the risk of logical conflicts: think, for example, to two developers creating an attribute with the same code. Mageploy can facilitate our deployment tasks a lot but can't work magic; even Git can't automatically solve code conflicts after all.</p>

                    <h2>1.2 Installation and Setup</h2>

                    <p>To install Mageploy easily we suggest you to install Modman (Module Manager) by Colin Mollenhour; you can find the instructions to install Modman here: <a href="https://github.com/colinmollenhour/modman">https://github.com/colinmollenhour/modman</a>.</p>

                    <p>Once you have Modman installed, go to the root folder of your Magento project and type the following commands to initialize Modman:</p>

                    <pre><code>$ modman init</code></pre>

                    <p>and then,  to clone Mageploy from its git repository via ssh:</p>

                    <pre><code>$ modman clone git@github.com:pug-more/mageploy.git</code></pre>

                    <p>After that, clear your Magento Cache, if enabled, and run Magento Compilation Process if Compilation is enabled. We assume you know how to perform such tasks. If not, you'd better know.</p>

                    <p>At this point Mageploy should be up and running but still needs some configuration changes.</p>

                    <p>Go to System -&gt; Configuration -&gt; Advanced -&gt; Developer section and  expand the "Mageploy" tab.
                        Then you can change the values of the following configuration parameters:</p>

                    <ul>
                        <li>
                            <strong>Active:</strong> choose whether to activate action tracking. By default tracking is active. Activation can be performed faster through the command line, as we will see in the section dedicated to the command line tool.</li>
                        <li>
                            <strong>Debug mode:</strong> if set to Yes, Mageploy will write logs even if logging is disabled in Magento.</li>
                        <li>
                            <strong>Specific User Identification:</strong> by default it is set to "anonymous" and we encourage you to change this value and set a unique identifier among the different environments the project is developed and deployed on. This way, when you'll show the history of global changes, you will be able to distinguish who did what. Another reason to differentiate this value among different environments is that doing so you will enforce the  probability to avoid conflicts among global actions.</li>
                    </ul><p>There is only one step remaining to begin taking advantage from the usage of Mageploy. 
                        Run the following command from the root folder of your Magento project:</p>

                    <pre><code>$ php shell/mageploy.php --status
</code></pre>

                    <p>At this point you should see something similar to the following</p>

<pre><code>Mageploy v 1.1.3 - <span style="color:red">tracking is not active</span> - <span style="color:green">user is aronchi</span>
There aren't any pending actions to execute.
</code></pre>

                    <p>Most important, your first invocation of Mageploy's command line tool has the effect of creating a folder named "mageploy" under Magento's "var" folder and initializing the "mageploy_all.csv" and "mageploy_executed.csv" files. Put the "mageploy_all.csv" under version control and ignore "mageploy_executed.csv" from version control and you are almost done.</p>

                    <h2>1.3 Basic Usage</h2>

                    <p>Once Mageploy is configured and tracking is activated, actions you perform in certain sections of Magento Admin Panel are tracked both into "mageploy_all.csv" and "mageploy_executed.csv" files.</p>

                    <p>Replicating tracking in both files serves the purpose of instructing Mageploy about which actions have been executed locally (the ones in "mageploy_executed.csv" which has not to be put under version control) and don't have to be replicated while reading the global actions (the ones in "mageploy_all.csv", which has to be put under version control).</p>

                    <p>That's quite all you have to know, except that you have to learn how to use the Command Line Tool. See the  following paragraph dedicated to the Command Line Tool for further instructions.</p>

                    <h2>1.4 The Command Line Tool</h2>
                    
                    <p>The Command Line Tool allows you to monitor Mageploy's tracking status and history, enable or disable tracking, running pending actions that, once executed, should keep tracked areas of Magento easily aligned.</p>
                    
                    <p>To get an overview of different commands you can issue on the Command Line Tool, you can try the following (assuming you are on the Magento root installation folder):</p>
                    
                    <pre><code>$ php shell/mageploy.php --help</code></pre>
                    
                    <p>The result will be somthing like the following:</p>
                    
<pre><code>Mageploy v 1.1.3 - <span style="color:red">tracking is not active</span> - <span style="color:green">user is aronchi</span>

Usage:	php mageploy.php --[options]

--h/help            to show this help
--t/track [val]     0 to disable tracking, any other value or blank to enable it
--hi/history [n]    Show the last n changes. Leave n blank to show all
--s/status          Show if there are any changes to be imported
--r/run [id]        Import changes for specified action (not recommended); leave id blank to import all
</code></pre>
                    
                    <p>As you can see, you can use a short version for each option and it's what we suggest you to do, unless you are paid for the number of characters you type on a keyboard.</p>

                    <p>Now let's see how the different options operates.</p>
                    
                    <h3>1.4.1 Activating/Deactivating tracking</h3>
                    
                    <p>Sometimes deactivating trackers can be useful or necessary; for example you may need to change values in System Config that you don't want to propagate to other environments. Or maybe you need to create a test Attribute or Category and delete them after you have done your tests without the need to deploy these actions.</p>
                    
                    <p>To <strong>deactivate</strong> all the trackers at the same time, you can use the following command:</p>
                    
<pre><code>$ php shell/mageploy.php -t 0</code></pre>
                    
                    <p>To <strong>activate</strong> all the trackers at the same time, you can use the following command:</p>
                    
<pre><code>$ php shell/mageploy.php -t 1</code></pre>
                    
                    <p>Note that omitting the value after the <code>-t</code> option corresponds to activating the tracking.</p>
                    
                    <p>Remember that the same option can be changed via the Magento Admin Control Panel in the "Mageploy" tab under System -> Configuration -> Advanced -> Developer section. But it's far more easy to change it via the Command Line Tool, isnt' it?</p>

                    <h3>1.4.2 Showing tracking history</h3>
                    
                    <p>To show the list of all tracked actions so far, type the following:</p>

<pre><code>$ php shell/mageploy.php -hi</code></pre>

                    <p>If you have tracked something so far, you should obtain something like:</p>

<pre><code>Mageploy v 1.1.3 - <span style="color:red">tracking is not active</span> - <span style="color:green">user is aronchi</span>

Global Actions list:
ID: 1	 - Save existing Attribute Set with UUID 'Test Group' (aronchi on Thu Mar 14 11:25:25 2013)
ID: 2	 - Save existing Attribute Set with UUID 'Test Group' (aronchi on Thu Mar 14 11:29:41 2013)
ID: 3	 - Save existing Attribute Set with UUID 'Test Group' (aronchi on Thu Mar 14 11:34:54 2013)
ID: 4	 - Save existing Attribute Set with UUID 'Test Group' (aronchi on Thu Mar 14 11:35:15 2013)
ID: 5	 - Save existing Attribute Set with UUID 'Test Group' (aronchi on Thu Mar 14 11:35:45 2013)
ID: 6	 - Save Static Block 'footer_links' (aronchi on Thu Mar 14 13:43:06 2013)
ID: 7	 - Save Static Block 'footer_links' (aronchi on Thu Mar 14 13:45:55 2013)
ID: 8	 - Save Static Block 'footer_links' (aronchi on Thu Mar 14 13:48:42 2013)
ID: 9	 - Save Static Block 'footer_links' (aronchi on Thu Mar 14 13:50:18 2013)
ID: 10	 - Save Static Block 'sample_block' (aronchi on Thu Mar 14 13:55:29 2013)
ID: 11	 - Save Static Block 'customer-service' (aronchi on Thu Mar 14 14:03:17 2013)
ID: 12	 - Save Static Block 'another-sample-page' (aronchi on Thu Mar 14 14:05:22 2013)
ID: 13	 - Save new CMS Page 'another-sample-page' (aronchi on Thu Mar 14 14:19:43 2013)
ID: 14	 - Save existing CMS Page 'another-sample-page' (aronchi on Thu Mar 14 14:26:55 2013)
ID: 15	 - Save existing CMS Page 'customer-service' (aronchi on Thu Mar 14 14:35:38 2013)
ID: 16	 - Save existing CMS Page 'customer-service' (aronchi on Thu Mar 14 14:38:51 2013)

Total global actions listed: 16
</code></pre>
                    
                    <p>You can specify a number, say 5, after the <code>hi</code> option in order to show the list of the last five actions tracked so far:</p>
                    
<pre><code>$ php shell/mageploy.php -hi 5</code></pre>

<pre><code>Mageploy v 1.1.3 - <span style="color:red">tracking is not active</span> - <span style="color:green">user is aronchi</span>

Global Actions list:
ID: 12	 - Save Static Block 'another-sample-page' (aronchi on Thu Mar 14 14:05:22 2013)
ID: 13	 - Save new CMS Page 'another-sample-page' (aronchi on Thu Mar 14 14:19:43 2013)
ID: 14	 - Save existing CMS Page 'another-sample-page' (aronchi on Thu Mar 14 14:26:55 2013)
ID: 15	 - Save existing CMS Page 'customer-service' (aronchi on Thu Mar 14 14:35:38 2013)
ID: 16	 - Save existing CMS Page 'customer-service' (aronchi on Thu Mar 14 14:38:51 2013)

Total global actions listed: 5
</code></pre>
                    
                    <p>In case you never tracked anything before, you will simply get:</p>
<pre><code>Mageploy v 1.1.3 - <span style="color:red">tracking is not active</span> - <span style="color:green">user is aronchi</span>

There aren't any actions tracked.
</code></pre>
                    
                    
                    <h3>1.4.3 Showing tracking status</h3>
                    
                    <p>Say that you have just updated the "mageploy_all.csv" file from your preferred Source Control System; the first thing we suggest to do, at his point, is typing the following:</p>

<pre><code>$ php shell/mageploy.php -s</code></pre>                    
                    
                    <p>Something similar to the following could appear:</p>

<pre><code>Mageploy v 1.1.3 - <span style="color:red">tracking is not active</span> - <span style="color:green">user is aronchi</span>
                    
Pending Actions list:
ID: 17	 - Save existing CMS Page 'about-us' (rgambuzzi on Thu Mar 15 15:17:47 2013)

Total pending actions: 1                    
</code></pre>

                    <p>What does it mean? Simply put, our working mate whose username is "rgambuz" has done some changes on the existing "about-us" CMS Page; he has tracked his changes and now Mageploy knows that this has to be replicated in your environment. That's where Mageploy can start showing off its potential.</p>
                    
                    <h3>1.4.4 Running pending actions</h3>
                    
                    <p>Once you have some pending actions to be executed, you can instruct Mageploy to run execute them all to keep different environments aligned. In other words, type:</p>

<pre><code>$ php shell/mageploy.php -r</code></pre>                    
                    
                    <p>And you will get something similar to the following:</p>
                    
<pre><code>Mageploy v 1.1.3 - <span style="color:red">tracking is not active</span> - <span style="color:green">user is aronchi</span>
                    
Action ID #17 - <span style="color:green">success</span> The page has been saved.

Executed actions: 1/1                    
</code></pre>      
                    <p>Note that you can also run pending actions one by one specifying the action's ID after the <code>run</code> option. <strong>But pay attention:</strong> doing so you run the risk to break the correct sequence in which actions were executed and this can cause problems. If, for example, you run the action that associates an Attribute to an Attribute Set before the Attribute is created, you can imagine that this will cause some errors. So we advice you not to run actions one by one unless you are really sure of what you are doing. We implemented this function mainly for debugging purposes.</p>
                    
                    <h2>1.5 Summary</h2>

                    <p>Mageploy is really easy to install provided you know what <a href="https://github.com/colinmollenhour/modman" title="Go to Modman project">Modman</a> is and how to use it. Once installed configuration is a matter of flushing Magento's cache and compilation, setting up your username and putting the <em>&lt;magentodir&gt;/var/mageploy/mageploy_all.csv</em> file under version control.</p>
                    
                    <p> Once you switch Mageploy's tracking function on, you will get your actions recorded (depending on which trackers are implemented and activated) and have the ability to synchronize different environments running actions executed by others. That's simply done by updating the versioned <em>mageploy_all.csv</em> file and using the Command Line Tool.</p>
                    
                    <h1>2. Trackers</h1>

                    <p>Trackers are a core part of Mageploy and are designed following 
                    "the Magento way" of doing things. 
                    Doing so, trackers can easily be added to Mageploy by external 
                    modules using configuration directives.</p>
                    
                    <p>Mageploy comes bundled with some trackers designed to keep track 
                    of some Magento core functionalities.<br/>
                    Mageploy, however, can't know in advance the internals of 
                    custom modules; so trackers of custom modules should be 
                    implemented by third parties, typically the same who 
                    implements the module itself.</p>
                    
                    <p>The key functionality for a Tracker is the one of converting 
                    specific IDs into Universally Unique Identifiers (UUIDs).<br/>
                    Without this ability, a Tracker couldn't even exist.<br/>In the 
                    following sections we will describe how we implemented IDs to 
                    UUIDs conversion for out-of-the-box trackers adding some 
                    considerations about limitations when needed.</p>
                    
                    <p>Converting IDs into UUIDs is done in the <em>encoding</em> 
                    method which is called every time you invoke a Controller's Action.<br/>
                    Converting back UUIDs into IDs is done in the <em>decode</em> method
                    invoked by the Command Line Tool every time it excutes pending actions.<br/>
                    
                    <p>At the moment this is all you have to know about
                        Mageploy's internals in order to understand what's next.<br/>
                        We will examine all this in more depth in the 
                        <a href="#extending-mageploy">Extending Mageploy</a> section.</p>

                    <h2>2.1 About Trackers</h2>
                    
                    <p>When Mageploy was still only an idea in our minds, we needed 
                    a "proof of concept" which could demonstrate that a tool like
                    Mageploy could be really useful to developers and, first of all, 
                    to ourselves.<br/>
                    So we wrote up a list of "most desirable" Trackers, that is 
                    a way of listing things that were boring to implement in 
                    Magento every time we had to start a new project.</p>
                    
                    <p>At the top of that list there were Attributes and Attribute Sets.<br/>
                    Every time a new project starts on Magento, you likely have 
                    to set up new entities; creating new Attributes and associating them 
                    to Attribute Sets and Groups is a frequent task. What's also frequent is 
                    deleting them, changing their options (is it searchable? Is it visible on Frontend?
                    Is it used for Simple or other kind of Product types? And so on),
                    assigning them to Sets and Groups etc.</p>
                    
                    <p>Best Magento practices impose to do all this thing via source code, 
                    that is, developing install and upgrade scripts in custom Modules
                    which programmatically do all the sort of tasks described above.</p>
                    
                    <p>But, you know, the knowledge of the entire system comes with 
                    time and each time you (or your customer) change your mind about some
                    detail you have to write an upgrade script in order to propagate
                    these changes.</p>
                    
                    <p>Frankly: all this is boring and error prone, especially
                    considering that Magento comes with a convenient Admin Panel 
                    which let you easily do this stuff. What's more, delegating the 
                    creation of such entities to developers means cutting away
                    store managers and web designers from giving their contribute 
                    to setting up the store. Not realistic and, from developers' 
                    point of view, not funny.</p>
                    
                    <p>That's where Mageploy comes to hand: you can continue using
                    the Admin Panel without worrying about propagation and synchronization,
                    provided a tracker is silently working in the background registering
                    your actions.</p>                        

                    <h2>2.2 Attribute Tracker</h2>
                    
                    <p>The Attribute Tracker tracks down the action of creating 
                        and updating an Attribute.</p>
                    
                    <p>Implementing its core wasn't so hard because Attributes
                    comes with a <em>built-in</em> universally unique identifier
                    (or UUID) which is the Attribute Code. What's more, once you
                    create an Attribute in Magento Admin Panel, you can't change
                    its Code so you can be sure that the UUID won't change in time.</p>
                    
                    <p>So, encoding and decoding of the IDs is really easy and 
                        follows the easy rule below:
                    </p>
                        <ul>
                            <li><code>Attribute UUID = Attribute Code</code></li>
                        </ul>
                    <p>The hardest part comes when an Attribute has some Options 
                        associated, beacuse they don't have an immutable identifier.</p>
                    
                    <p>In order to make things work we were obliged to do our first 
                        assumption: <em>Attribute Options Admin values should be immutable</em>.</p>
                    
                    <p>Thanks to the above assumption, it's easy to keep track of 
                        changes to existing options and distinguish them from new 
                        options created at a later stage.</p>
                    
                    <p>Assuming we use a string separator called 
                        <code>UUID_SEPARATOR</code> in UUIDs that serves the 
                        function to split different parts while decoding them, the
                        Options rule is the following:
                    </p>
                        <ul>
                            <li><code>Existing Option UUID = 'existing_opt'.UUID_SEPARATOR.'&lt;Option Admin Value&gt;'</code></li>
                            <li><code>New Option UUID = 'new_opt'.UUID_SEPARATOR.'option_&lt;option_number&gt;'</code></li>
                        </ul>
                    <p>
                        To decode an existing Option UUIDs we can extract the Admin 
                        Value and, knowing the Attribute it belongs to, find its specific ID. 
                        This works as far as we respect the assumption of leaving 
                        the Admin value unchanged over time.
                    </p>
                    <p>
                        From a new Option UUIDs, instead, we simply extract the 'option_&lt;option_number&gt;'
                        and give it back to the Controller's Action. This way the 
                        new Option will be generated for the Attrbute the Option belongs to.
                    </p>
                    <h2>2.3 Attribute Set Tracker</h2>
                    
                    <p>The Attribute Set Tracker tracks down the action of creating 
                        and updating an Attribute Set, creating and updating an 
                        Attribute Group and associating existing Attributes to a 
                        (new or existing) Group of a (new or existing) Attribute Set.</p>
                    
                    <p>This was our real proof of concept for Mageply because here
                        difficulty scales up a bit. That's dued to the fact that
                        in some circumstances we can't rely on an explicit 
                        UUIDs like the Attribute Code.</p>
                    
                    <p>As far as we have to deal with creating a new Attribute Sets, 
                        things are simple because Magento requires that
                    different Attribute Sets should have different names, so:</p>
                    <ul>
                        <li><code>Attribute Set UUID = Attribute Set Name</code></li>
                    </ul>
                    
                    <p>From now on, we split topics into sub topics because on an 
                        Attribute Set you can associate Attribute to Groups, create
                        new Groups, remove the association between an Attribute
                        and a Group and remove Groups.</p>
                    
                    <h3>2.3.1 Associatig Attributes to Groups</h3>
                    
                    <p>The structure we have to deal when handling the association 
                        of each Attribute to Groups is a list of indexed arrays like the following:</p>
                    
<pre><code>0 => &lt;attribute_id&gt;
1 => &lt;attribute_group_id&gt;
2 => &lt;sort_order&gt;
3 => &lt;eav_attribute_id&gt; //empty if it's a new association</code></pre>
                    
                    <p>So here we have to convert different IDs into UUIDs:</p>
                    
                    <ul>
                        <li><code>Attribute UUID = Attribute Code</code></li>
                        <li><code>Existing Attribute Group UUID = Attribute Group Name . UUID_SEPARATOR . Attribute Set Name</code></li>
                        <li><code>New Attribute Group UUID = the &lt;attribute_group_id&gt; value in the array</code></li>
                        <li><code>EAV Attribute UUID = Attribute Group UUID . UUID_SEPARATOR . Attribute UUID</code></li>
                    </ul>
                    
                    <h3>2.3.2 Creating and Updating Groups</h3>
                    
                    <p>The structure we have to deal when handling the creation of Groups is a list of indexed arrays like the following:</p>
                    
<pre><code>0 => &lt;attribute_group_id&gt; or "ynode-&lt;NUM&gt;" for a new Group
1 => &lt;attribute_group_name&gt;
2 => &lt;sort_order&gt;</code></pre>
                    
                    <p>So, the only ID we have to convert is the one of the Group. 
                        Using the name can't be sufficient, as Attribute Groups 
                        within different Attribute Sets can have the same name.<br/>
                        For this reason we concatenate the Group Name and the 
                        Attrbute Set Name as the latter can't be repeated for 
                        the same <em>entity type</em> (the Product, in current scope):
                    </p>
                    
                    <ul>
                        <li><code>Attribute Group UUID = Attribute Group Name . UUID_SEPARATOR . Attribute Set Name</code></li>
                    </ul>
                    
                    <p>Note that as we load the Attribute Group from the DB, 
                        changing the name of the Group is possible even if it's
                        part of the UUID.<br/>That's because in environments where 
                        the action of renaming the Attribute Group hasn't been 
                        run yet, the Group Name is the one in the UUID, so the
                        Group can be identified. Provided no one renames the same
                        Group in the same time but this would be considered a 
                        <em>conflict</em> and conflicts can't be resolved by
                        Mageploy; humans, in this case, have to step in and do
                        their part.</p>
                    
                    <h3>2.3.3 Removing Attributes from Groups</h3>
                    
                    <p>The structure we have to deal when handling the deletion 
                        of Attributes from an Attribute Set is an indexed array 
                        whose values are the Entity IDs of the Attributes to delete.</p>
                    
                    <p>We have an Entity Attribute ID because the same Attribute 
                    can be associated to different Sets and Groups, so the data
                    we have to deal with is a bit more structured.<br/>
                    This means we have to identify ad Attribute within specific 
                    Set and Group and we do this by providing the following UUID:</p>
                    
                    <ul>
                        <li><code>Entity Attribute UUID = Attribute Group UUID . UUID_SEPARATOR . Attribute UUID</code></li>
                    </ul>
                    
                    <p>That is, as you can guess:</p>
                    
                    <ul>
                        <li><code>Entity Attribute UUID = Attribute Group Name . UUID_SEPARATOR . Attribute Set Name . UUID_SEPARATOR . Attribute UUID</code></li>
                    </ul>
                    
                    <h3>2.3.4 Removing Groups</h3>
                    
                    <p>The structure we have to deal when handling the deletion 
                        of Groups is an indexed array whose values are the IDs 
                        of the Groups to delete.</p>
                    
                    <p>So encoding of such IDs is the same we have already seen above:</p>
                    
                    <ul>
                        <li><code>Attribute Group UUID = Attribute Group Name . UUID_SEPARATOR . Attribute Set Name</code></li>
                    </ul>
                    
                    <h2>2.4 Category Tracker (uncomplete)</h2>

                    <p>The Category Tracker tracks down the action of creating 
                        and updating a Category.<br/>
                        This Tracker is not complete in Mageploy v 1.1.3 because 
                        it doesn't track the Thumbnail and the Image uploads.</p>
                    
                    <p>We didn't deal with handling uploads at all in 
                        Mageploy 1.0.0; it will be certainly part of the very next 
                        improvements we have in mind.</p>
                    
                    <p>The Category Tracker wasn't as complex to implement as the
                    Attribute Set one but we had to deal with several topics:</p>
                    
                    <ul>
                        <li>Category ID</li>
                        <li>Store ID</li>
                        <li>Parent Category ID</li>
                        <li>Associated Products</li>
                        <li>Moving of the Category in the hierarchy</li>
                    </ul>
                    
                    <p>From now on, we split the above topics into sub topics in 
                        order to keep things more clear.</p>
                    
                    <h3>2.4.1 Category ID</h3>
                    
                    <p>Categories in Magento don't have a unique code out of the 
                        box as Attributes do. What's more, you are allowed to create
                        two or more Categories with the same name under the same
                        parent Category.</p>
                    
                    <p>In order to be able to convert a Category ID into a
                    Category UUID we had to assume that Categories 
                    with the same parent Category won't ever have the same name.</p>
                    
                    <p>Maybe it could have been easier to use the Category URL 
                        as UUID but we didn't want to deal with URL rewrites and 
                        chose to use a different algorithm.</p>
                    
                    <p>Provided we don't have to convert the ID for new Categories,
                        for existing ones the UUID is the concatenation
                        of the name of all the Categories in the Category path, ending
                        with current Category name.</p>

                    <ul>
                        <li><code>Category UUID = Full Named Path</code></li>
                    </ul>
                    
                    <p>In fact, assuming that there will never be two Categories 
                    with the same name under the same parent Category, such a path
                    will uniquely identify a Category.</p>

                    <h3>2.4.2 Store ID</h3>
                    
                    <p>Identifying a UUID from a Store ID is a trivial taks because
                    Stores have unique codes in Magento, so:</p>
                    
                    <ul>
                        <li><code>Store UUID = Store Code</code></li>
                    </ul>
                    
                    <h3>2.4.3 Parent Category ID</h3>
                    
                    <p>For the parent Category ID, refer to the conversion used 
                        for the Category ID in Paragraph 2.4.1.</p>
                    
                    <h3>2.4.4 Associated Products</h3>
                    
                    <p>Producs you associate to a Category through the "Category
                    Products" tab are passed as <code>product_id=position</code> string segments 
                    concatenated with an <code>&amp;</code> character; here is an example:</p>
                    
                    <code>1=0&11=1&12=2&13=3"</code>
                    
                    <p>So, converting such a string is a matter of converting 
                        each Product ID into a Product UUID and this is quite easy because
                        Products have a native unique identifier represented by the
                        <em>SKU</em>, so:</p>

                    <ul>
                        <li><code>Product UUID = Product SKU</code></li>
                    </ul>
                    
                    <h3>2.4.5 Moving of the Category in the hierarchy</h3>
                    
                    <p>Moving a Category in the hierarchy means handling information 
                        about the new parent Category and the Category after which
                    current Category has to be placed. So we are again in the case of
                    converting a Category ID and you can refer to paragraph 2.4.1.</p>
                    
                    <h2>2.5 System Config Tracker (uncomplete/experimental)</h2>
                    
                    <p>The System Config Tracker in Mageploy v 1.1.3 is not 
                        intended to be fully functional. The Magento System 
                        Config is a complex set of configuration sections, each 
                        of which should be deeply analyzed. For each section a
                        specific tracker should be written in order to do things
                        the right way.</p>
                    
                    <p>Instead, at the moment, the System Config Tracker 
                        consists of a single tracker which doesn't convert any 
                        ID but simply encodes and decodes posted values as is.</p>

                    <p>Despite this big limitation, the System Config Tracker 
                        can be very useful to track changes of a lot of config 
                        values which are intrinsically independent from specific
                        IDs.</p>

                    <h2>2.6 CMS Page Tracker</h2>
                    
                    <p>The CMS Page Tracker tracks down the action of creating 
                        and updating a CMS Page.</p>
                    
                    <p>This tracker wasn't complex to implement; the only 
                        aspect we had to deal with carefully was the 
                        association of a Page to one ore more Store Views and, 
                        thus, the conversion of Store IDs through the following 
                        rule:
                    </p>
                    
                    <ul>
                        <li><code>Store UUID = Store Code</code></li>
                    </ul>

                    <h2>2.7 Static Block Tracker</h2>
                    
                    <p>The Static Block Tracker tracks down the action of creating 
                        and updating a Static Block.</p>
                    
                    <p>Its implementation is equivalent to the CMS Page Tracker, 
                        so you can refer to it for further details.</p>

                    <h2>2.8 Summary</h2>
                    
                    <p>Trackers are the pieces of code which let Mageploy record
                        actions which can be rerun on different environments
                        via the Command Line Tool in order to keep things 
                        synchronized.</p>
                    
                    <p>In this section we explained the basic algorithms 
                        undergoing the built-in Trackers in order to give you a 
                        reference for the development of new Trackers.</p>
                    
                    <a name="extending-mageploy"></a>
                    <h1>3. Extending Mageploy</h1>
                    
                    <p>As we mentioned above, Mageploy is developed "the Magento 
                        way" meaning that you can extend Mageploy and 
                        deploy your own Trackers.</p>
                    
                    <p>Trackers can be built inside Mageploy's module or inside
                        your own module simply by extending a Configuration node 
                        and registering your own classes.</p>
                    
                    <p>Our idea is that Trackers dealing with Magento's core 
                        functionalities should be delivered directly as
                        Mageploy's built-in Trackers meanwhile third party 
                        Modules could provide their own Trackers.</p>
                    
                    <p>Provided that third party Trackers are not mandatory, once 
                        you begin working with Mageploy you will desire to have 
                        a Tracker for every section. Count on it.</p>

                    <h2>3.1 Tracker Basics</h2>
                    
                    <p>Before explaining how Trackers work let's explain how
                        they are activated.</p>
                    
                    <h3>3.1.1 The Request Observer</h3>
                    
                    <p>The tracking functionality is based upon an Observer's 
                        method, <code>observeRequest()</code>, which is invoked
                        each time Magento dispatches the 
                        <code>controller_action_predispatch</code> event.
                    </p>
                    
                    <p>The <code>observeRequest()</code>, implementation is very 
                        simple as shown below:
                    </p>
                    
<pre><code>public function observeRequest($observer) {
    $helper = Mage::helper('pugmore_mageploy');
    if (!$helper->isActive()) {
        return;
    }

    $request = Mage::app()->getRequest();
    $funnel = Mage::getModel('pugmore_mageploy/request_funnel')
            ->init(Mage::getSingleton('pugmore_mageploy/io_file'))
            ->dispatch($request);
}
</code></pre>                    
                    
                    <p>The first code block checks whether tracking is active; 
                        if not nothing has to be done. Easy.</p>
                    
                    <p>The second code block instantiates the so called 
                        "Request Funnel" object, injects into it the object 
                        responsible of writing things into files and calls the
                        <code>dispatch()</code> method, passing the Request 
                        Object as its only parameter. Done. Easy too.</p>
                    
                    <p>The reason why the I/O object is injected is that we 
                        didn't want to bound Mageploy to the initial decision 
                        of using files to synchronize things. If one day another
                        better method will arise, we can simply change the object
                        responsible of writing things and all should continue
                        working without worrying about what comes after the 
                        <code>dispatch()</code> invocation. This way of doing 
                        things is named "Dependency Injection" and follows the 
                        "Inversion of Control" design pattern which we are great 
                        fan of. Magento is not implemented this way but Magento 2 
                        is, and this is a good piece of news.</p>

                    <h3>3.1.2 The Request Funnel</h3>
                    
                    <p>The Request Funnel object is responsible of taking the 
                        HTTP Request object, checking Magento configuration to 
                        retrieve and instantiate all the Trackers which can be 
                        interested in the action being submitted and, for each 
                        of them, calling their <code>encode()</code> method.
                    </p>
                    
                    <p>The <code>encode()</code> method of each Tracker will
                        return the result which the I/O injected Object is 
                        responsible to store.</p>
                    
                    <p>Even if more than a Tracker can be activated upon an 
                        action submission, at the moment the Trackers we developed
                        react once at a time.<br/>
                        The tracking of the System Configuration, if developed 
                        the right way, is a good candidate to expose more than a 
                        Tracker reacting at the same time to a same action 
                        submission. But actually it is not.</p>
                    
                    <p>The Request Funnel logic con be divided into two main 
                        blocks: the initialization one and the dispatching/recording one.</p>
                    
                    <p>The <code>init()</code> method's implementation is shown 
                        below:</p>
                    
<pre><code>public function init($io) {
    $this->_io = $io;

    Mage::dispatchEvent('mageploy_funnel_collect_actions_before', array('funnel'=>$this));

    $actionsInfo =  Mage::getConfig()->getNode(self::XML_ACTIONS_PATH)->asArray();

    Varien_Profiler::start('mageploy::funnel::collect_actions');
    foreach ($actionsInfo as $actionCode => $actionInfo) {
        if (isset($actionInfo['disabled']) && $actionInfo['disabled']) {
            continue;
        }
        if (isset($actionInfo['class'])) {
            $action = new $actionInfo['class'];
            $this->addAction($actionCode, $action);
        }
    }
    Varien_Profiler::stop('mageploy::funnel::collect_actions');

    Mage::dispatchEvent('mageploy_funnel_collect_actions_after', array('funnel'=>$this));

    return $this;
}</code></pre>
                    
                    <p>It's a very simple block of code, mainly inspired by the 
                        <code>init()</code> method of the 
                        <code>Mage_Core_Controller_Varien_Front</code> class.</p>
                    
                    <p>It simply access Magento Configuration nodes in order to
                        collect all registered trackers. Once a Tracker node is 
                        found and provided it's not disabled and is associated 
                        to a class it's stored in a protected list that will be 
                        iterated during the dispatching/recording phase.</p>
                    
                    <p>The <code>dispatch()</code> method's implementation is
                    ridiculously simple as shown below:</p>
                    
<pre><code>public function dispatch($request)
{
    foreach ($this->getActions() as $action) {
        if ($action->setRequest($request)->match()) {

            $this->record($action);
        }
    }
}</code></pre>
                    
                    <p>The <code>dispatch()</code> method iterates the list of
                        collected Trackers and invoke their <code>record()</code>
                        method.</p>
                    
                    <p>The <code>record()</code> method's implementation is
                    very simple too, as shown below:</p>

<pre><code>public function record($action) {
    Mage::dispatchEvent('mageploy_funnel_record_action_before', array('funnel'=>$this, 'action'=>$action));

    Varien_Profiler::start('mageploy::funnel::record_action');

    Mage::helper('pugmore_mageploy')->log("Should record '%s'", $action->toString());
    $result = $action->encode();
    ksort($result);
    $this->_io->record($result);

    Varien_Profiler::stop('mageploy::funnel::record_action');

    Mage::dispatchEvent('mageploy_funnel_record_action_after', array('funnel'=>$this, 'action'=>$action));

    return $this;
}</code></pre>            
                    
                    <p>Given a Tracker (the <code>$action</code> parameter), the
                        <code>record()</code> method calls <code>encode()</code>
                        upon it and demands the I/O Object to store the result.<br/>
                        The result is an array and the <code>ksort($result)</code>
                        ensures that the sort order of its colums will be preserved.</p>
                    
                    <p>As you have seen, the tracking logic is extremely simple.
                        The hardest part, as you can guess, is demanded to the 
                        <code>encode()</code> and <code>decode()</code> methods
                        of each Tracker.</p>
                    
                    <h2>3.2 Adding a Tracker</h2>

                    <p>To add a Tracker, the first step is to register the 
                        configuration node which will be read by the Funnel Object
                        during the <code>init()</code> method, as seen before.
                    </p>
                    
                    <p>Regardless of the fact that you are working on Mageploy's
                        code base or in your own module, the structure of the
                        configuration node is the same, and is shown below:</p>
                    
<pre><code>&lt;config&gt;
    &lt;default&gt;
        &lt;mageploy&gt;
            &lt;actions&gt;
                &lt;your_tracker_identifier&gt; 
                    &lt;disabled&gt;0&lt;/disabled&gt;
                    &lt;class&gt;Vendor_Module_Model_ClassName&lt;/class&gt;
                &lt;/your_tracker_identifier&gt;
            &lt;/actions&gt;
        &lt;/mageploy&gt;
    &lt;/default&gt;
&lt;/config&gt;</code></pre>                    
                    
                    <p>If you are extending the Mageploy's code base, the 
                        <code>Vendor_Module_Model_ClassName</code> is recommended to be
                        <code>PugMoRe_Mageploy_Model_Action_&lt;YourClassName&gt;</code>.
                    </p>
                    
                    <p>The <code>&lt;disabled&gt;</code> tag allows you to disable a the
                        Tracker by specifying values other than <code>0</code>.</p>
                    
                    <p>The <code>&lt;class&gt;</code> tag should containg the fully
                        qualified name of an existing class extending 
                        <code>PugMoRe_Mageploy_Model_Action_Abstract</code> base class.</p>
                    
                    <h2>3.3 Developing a Tracker</h2>

                    <p>As mentioned above, your Tracker class should extend the
                        <code>PugMoRe_Mageploy_Model_Action_Abstract</code> base class.</p>
                    
                    <p>The base class already provides an <code>encode()</code> 
                        method which however doesn't do anything useful. That 
                        means that, despite you should implement your own method,
                        PHP interpreter won't complain if you don't.</p>
                    
                    <p>On the other hand, the base class also declares an 
                        <code>abstract function decode(...)</code>, which means
                        that you are obliged to provide an implementation as far 
                        as you don't want the PHP interpreter to complain about
                        a missing method in your class.</p>
                    
                    <h3>3.3.1 A sample Tracker</h3>
                    
                    <p>Let's show how to implement a StoreView Tracker in order 
                        to learn the basics of Tracker implementation.<br/>
                        We will implement it into Mageploy's code base, so here
                        is our configuration node:</p>
                    
<pre><code>&lt;config&gt;
    &lt;default&gt;
        &lt;mageploy&gt;
            &lt;actions&gt;
                &lt;store_storeview&gt; 
                    &lt;disabled&gt;0&lt;/disabled&gt;
                    &lt;class&gt;PugMoRe_Mageploy_Model_Action_Store_StoreView&lt;/class&gt;
                &lt;/store_storeview&gt;
            &lt;/actions&gt;
        &lt;/mageploy&gt;
    &lt;/default&gt;
&lt;/config&gt;</code></pre>                    

                    <p>And here is the very first implementation of the Tracker
                        class:</p>
                    
<pre><code>class PugMoRe_Mageploy_Model_Action_Store_StoreView extends PugMoRe_Mageploy_Model_Action_Abstract {
    const VERSION = '1';
    
    protected $_code = 'system_store';
    protected $_blankableParams = array('key', 'form_key');

    protected function _getVersion() {
        return Mage::helper('pugmore_mageploy')->getVersion(2).'.'.self::VERSION;
    }
    
    public function match() {
        if (!$this->_request) {
            return false;
        }

        if ($this->_request->getModuleName() == 'admin') {
            if ($this->_request->getControllerName() == 'system_store') {
                if (in_array($this->_request->getActionName(), array('deleteStorePost'))) {
                    return true;
                }
                if (in_array($this->_request->getActionName(), array('save'))) {
                    if ($this->_request->getParam('store_type') == 'store') {
                        return true;
                    }
                }
            }
        }

        return false;
    }
    
    public function encode() {
        $result = parent::encode();
        return $result;
    }

    public function decode($encodedParameters, $version) {
        // The !empty() ensures that rows without a version number can be 
        // executed (not without any risk).
        if (!empty($version) && $this->_getVersion() != $version) {
            throw new Exception(sprintf("Can't decode the Action encoded with %s Tracker v %s; current Store View Tracker is v %s ", $this->_code, $version, $this->_getVersion()));
        }

        $parameters = $this->_decodeParams($encodedParameters);
        $request = new Mage_Core_Controller_Request_Http();
        $request->setPost($parameters);
        $request->setQuery($parameters);

        return $request;
    }
    
}</code></pre>
                    
                    <p>The <code>const VERSION = '1';</code> is used to keep
                    track of internal Tracker version. This number should
                    change every time you make a change in the encoding  
                    logic in order to prevent Mageploy to decode actions encoded
                    with different algorithms, which will likely bring to an error.</p>
                    
                    <p>The <code>protected $_code = 'system_store';</code> should 
                    uniquely identify the Tracker; this string is used in logging and
                    printing and is usually identical to corresponding action 
                    name even if this is not mandatory.</p>
                    
                    <p>The <code>_getVersion()</code> function can't be generalized 
                        because it accesses the local <code>VERSION</code> constant 
                        but it's basically always the same code. We admit this is
                        not something we like much.</p>
                    
                    <p>The <code>match()</code> function should return 
                        <code>true</code> when current Tracker intercepts an 
                        action it is interested to track.</p>
                    
                    <p>typically we track actions which belongs to the 
                        <code>Mage_Adminhtml</code> Module, whose name is 
                        <code>admin</code>; in particular, the Store View Tracker 
                        should intercept the <code>save</code> and <code>deleteStorePost</code>
                        action belonging to the <code>system_store</code> Controller.
                        Note that in case of <code>save</code>, a match should 
                        occurre if and only if the value of the <code>store_type</code> 
                        Request parameter equals <code>store</code>. This logic
                        is implemented in the portion of the <code>match()</code>
                        method implementation shown below:</p>

<pre><code>if ($this->_request->getModuleName() == 'admin') {
    if ($this->_request->getControllerName() == 'system_store') {
        if (in_array($this->_request->getActionName(), array('deleteStorePost'))) {
            return true;
        }
        if (in_array($this->_request->getActionName(), array('save'))) {
            if ($this->_request->getParam('store_type') == 'store') {
                return true;
            }
        }
    }
}
</code></pre>                  
                    
                    <p>At this point our Tracker will intercept and match the 
                        <code>save</code> action of the 
                        <code>Mage_Adminhtml_System_StoreController</code> but
                        it doesn't anything interesting yet.</p>
                    
                    <p>If we take a look at the Request parameters submitted upon
                    saving an existing Store View, we have a structure similar 
                    to the following:</p>
                    
<pre><code>[form_key]	string	"XevyrSTGSeiLZ5hj"	
[store]	array[7]		
  [group_id]	string	"1"	
  [name]	string	"Secondary Store View"	
  [code]	string	"secondary"	
  [is_active]	string	"1"	
  [sort_order]	string	"0"	
  [is_default]	string	""	
  [store_id]	string	"3"	
[store_type]	string	"store"	
[store_action]	string	"edit"	
</code></pre>            
                    <p>In case we save a new Store View the structure is the 
                        same with a difference: the <code>store_id</code> value
                        is (reasonably) an empty string.</p>
                    
                    <p>So, what our encoding function should do? It should:</p>
                    
                    <ul>
                        <li>eliminate useless parameters that can cause errors while
                            executing back; in our example it's the <code>form_key</code>;</li>
                        <li>convert the <code>group_id</code> specific ID into 
                            its relative UUID. Because Store Groups don't have any
                            unique code, we have to impose the (reasonable) 
                            assumption that we won't have different Store Groups
                            with the same name.</li>
                        <li>convert the <code>store_id</code> specific ID into 
                            its relative UUID, if it is present. It's easy, 
                            because Store Views have a unique code and this will 
                            represent our UUID.</li>
                    </ul>
                    
                    <p>The decoding function should implement the steps which 
                        permit to obain the same structure with specific IDs 
                        starting from the unspecific one generated by the 
                        encoding process.</p>
                    
                    <p>Once we implement the <code>encode</code> and <code>deencode</code>
                        functions we are almost done; Mageploy will do the rest.</p>
                    
                    <p>The result that the <code>encode()</code> method will 
                        return is an indexed array whise colums are explained 
                        below:</p>
                    
                    <ul>
                        <li><code>INDEX_ACTION_TIMESTAMP</code> (index: 0): 
                        it's used to store the timestamp the result was
                        generated; it's populated by the base abstract class and
                        you should not need to change it.</li>
                        
                        <li><code>INDEX_ACTION_USER</code> (index: 1):
                        it's used to store the user which accomplished the action;
                        it's populated by the base abstract class and
                        you should not need to change it. The value is taken from
                        Mageploy's configuration and it's strictly recommended that
                        each user sets his own username.</li>
                        
                        <li><code>INDEX_ACTION_DESCR</code> (index: 2):
                        it's used to store a specific description, so the 
                        <code>encode()</code> method should specifically populate 
                        this field. This is the message you will see when issuing 
                        a <em>status</em> or <em>history</em> command via the 
                        Command Line tool.</li>
                        
                        <li><code>INDEX_EXECUTOR_CLASS</code> (index: 3):
                        it's used to store the name of the class used to encode
                        and decode current action. This is likely current Tracker 
                        class name.</li>
                        
                        <li><code>INDEX_CONTROLLER_MODULE</code> (index: 4):
                         it's used to store the Module name of the Controller
                         which implements the tracked action. typically it's 
                         current Controller's Module name but in some 
                         circumstances it can be different, so specifying it is
                         upon the <code>encode()</code> method.
                        </li>
                        
                        <li><code>INDEX_CONTROLLER_NAME</code> (index: 5):
                         it's used to store the Controller name, which is 
                         typically current Controller name.</li>
                        
                        <li><code>INDEX_ACTION_NAME</code> (index: 6):
                        it's used to store the Action name, which is typically 
                        current Action name.</li>
                        
                        <li><code>INDEX_ACTION_PARAMS</code> (index: 7):
                        it is used to store the parameters needed by the action
                        in order to be called again by the Command Line Tool. 
                        Parameters are serialized and then Base64 encoded in 
                        order to avoid problems while storing them in files. The
                        functions to encode and decode parameters are already 
                        provided by the abstract base class.</li>
                        
                        <li><code>INDEX_VERSION</code> (index: 8):
                        it is used to store a version number used in the 
                        <code>decode()</code> method to check decoding eligibility.
                        The version number is obtained concatenating the first two
                        digits of Mageploy's version number with current Tracker's
                        version. Infact, when encoding or decoding logic changes
                        in the base abstract class, the first and/or the second
                        digits of Mageploy's version number should be changed too, 
                        in order to prevent deconding of rows encoded with different
                        logics.</li>
                    </ul>
                    
                    <p>And here is the complete code of the Store View 
                        Tracker.</p>
                    
<pre><code>class PugMoRe_Mageploy_Model_Action_Store_StoreView extends PugMoRe_Mageploy_Model_Action_Abstract {
    const VERSION = '1';
    
    protected $_code = 'system_store';
    protected $_blankableParams = array('key', 'form_key');

    protected function _getVersion() {
        return Mage::helper('pugmore_mageploy')->getVersion(2).'.'.self::VERSION;
    }
    
    public function match() {
        if (!$this->_request) {
            return false;
        }

        if ($this->_request->getModuleName() == 'admin') {
            if ($this->_request->getControllerName() == 'system_store') {
                if (in_array($this->_request->getActionName(), array('deleteStorePost'))) {
                    return true;
                }
                if (in_array($this->_request->getActionName(), array('save'))
                    && $this->_request->getParam('store_type') == 'store') {
                        return true;
                }
            }
        }

        return false;
    }
    
    public function encode() {
        $result = parent::encode();

        if ($this->_request) {
            $params = $this->_request->getParams();
        
            // convert Group ID
            if (isset($params['store']) && ($groupId = $params['store']['group_id'])) {
                $group = Mage::getModel('core/store_group')->load($groupId);
                if ($group->getId()) {
                    $params['store']['group_id'] = $group->getName();
                }
            }

            $new = 'new';
            $actionName = $this->_request->getActionName();
            if (isset($params['store'])) {
                $storeCode = $params['store']['code'];            
            }
            
            // Convert Store ID
            if (isset($params['store']) && $storeId = $params['store']['store_id']) {
                $new = 'existing';
                $params['store']['store_id'] = $storeCode;
            }
            
            // Convert Item ID (for deleteStore action)
            if ($itemId = $params['item_id']) {
                $new = 'existing';
                $store = Mage::getModel('core/store')->load($itemId);
                if ($store->getId()) {
                    $storeCode = $params['item_id'] = $store->getCode();
                    $actionName = 'delete';
                }
            }
            
            foreach ($this->_blankableParams as $key) {
                if (isset($params[$key])) {
                    unset($params[$key]);
                }
            }
            
            $result[self::INDEX_EXECUTOR_CLASS] = get_class($this);
            $result[self::INDEX_CONTROLLER_MODULE] = $this->_request->getControllerModule();
            $result[self::INDEX_CONTROLLER_NAME] = $this->_request->getControllerName();
            $result[self::INDEX_ACTION_NAME] = $this->_request->getActionName();
            $result[self::INDEX_ACTION_PARAMS] = $this->_encodeParams($params);
            $result[self::INDEX_ACTION_DESCR] = sprintf("%s %s Store View '%s'", ucfirst($actionName), $new, $storeCode);
            $result[self::INDEX_VERSION] = $this->_getVersion();
        }
        
        
        return $result;
    }

    public function decode($encodedParameters, $version) {
        // The !empty() ensures that rows without a version number can be 
        // executed (not without any risk).
        if (!empty($version) && $this->_getVersion() != $version) {
            throw new Exception(sprintf("Can't decode the Action encoded with %s Tracker v %s; current Store View Tracker is v %s ", $this->_code, $version, $this->_getVersion()));
        }

        $parameters = $this->_decodeParams($encodedParameters);
        
        // Convert Group UUID
        if (isset($parameters['store']) && ($groupUuid = $parameters['store']['group_id'])) {
            $group = Mage::getModel('core/store_group')->load($groupUuid, 'name');
            if ($group->getId()) {
                $parameters['store']['group_id'] = $group->getId();
            }
        }
        
        // Convert Store UUID
        if (isset($parameters['store']) && $storeUuid = $parameters['store']['store_id']) {
            $store = Mage::getModel('core/store')->load($storeUuid, 'code');
            $parameters['store']['store_id'] = $store->getId();
        }        
        
        // Convert Item UUID (for deleteStore action)
        if ($itemUuid = $parameters['item_id']) {
            $store = Mage::getModel('core/store')->load($itemUuid, 'code');
            if ($store->getId()) {
                $parameters['item_id'] = $store->getId();
            }
        }
        
        $request = new Mage_Core_Controller_Request_Http();
        $request->setPost($parameters);
        $_SERVER['REQUEST_METHOD'] = 'POST'; // checked by StoreController
        $request->setQuery($parameters);
        return $request;
    }
    
}
</code></pre>                    
                    
                    <h2>3.4 Summary</h2>
                    
                    <p>Developing a Tracker is not a difficult task as Mageploy 
                        is developed "the Magento way": adding a Tracker is a 
                        matter of writing some XML (not so much) and a class
                        implementing tracking logic.</p>
                    
                    <p>The difficult part is studying the Controller action that
                        we want to track and implement the encoding and decoding
                        methods. In some circumstances, as the one seen in the 
                        above example, we will have to impose ourselves some 
                        constraints such the one of not having two Store Groups 
                        with the same name among the system.</p>
                    
                    <p>We hope that this documentation may have helped you 
                    understanding Mageploy's internals and that you will be
                    a happy Mageploy's user and, why not, contributor.</p>
                </section>

                <footer>
                    Mageploy is maintained by <a href="https://github.com/pug-more">pug-more</a><br>
                    Mageploy is an open source software distributed under the <a href="http://opensource.org/licenses/OSL-3.0">Open Software License (OSL 3.0)</a>.<br/>
                    This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="http://twitter.com/jasonlong">Jason Long</a>.
                </footer>


            </div>
        </div>
    </body>
</html>
